<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>游戏选择页面</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
            position: relative;
            overflow: hidden;
        }

        .game-button {
            padding: 20px 40px;
            margin: 10px;
            font-size: 18px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            transition: all 0.3s ease;
            width: 200px;
            height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            z-index: 2;
        }

        .game-button:hover {
            background-color: #45a049;
            transform: scale(1.05);
        }

        .preview-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.3s ease;
        }

        .preview-content {
            position: absolute;
            width: 300px;
            height: 300px;
            background-color: rgba(40, 40, 40, 0.95);
            border-radius: 10px;
            padding: 15px;
            color: white;
            text-align: center;
            opacity: 0;
            transform-origin: center bottom;
            transform: scaleY(0);
            transition: all 0.3s ease;
            border: 2px solid rgba(76, 175, 80, 0.3);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            box-sizing: border-box;
        }

        .preview-content.visible {
            opacity: 1;
            transform: scaleY(1);
        }

        .preview-content h2 {
            margin-bottom: 20px;
            color: #4CAF50;
            font-size: 1.8em;
            text-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
        }

        .preview-scores {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            border: 1px solid rgba(76, 175, 80, 0.2);
        }

        .preview-score-item {
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
        }

        .preview-score-item span:last-child {
            color: #4CAF50;
            font-weight: bold;
        }

        .preview-buttons {
            margin-top: 30px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .preview-button {
            width: 100%;
            padding: 12px;
            background-color: rgba(76, 175, 80, 0.8);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
        }

        .preview-button:hover {
            background-color: rgba(76, 175, 80, 1);
            transform: scale(1.05);
        }

        h1 {
            position: relative;
            z-index: 2;
            color: #333;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* 游戏预览面板样式 */
        .game-preview {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .game-board-preview {
            width: 100%;
            height: calc(100% - 50px);
            border: 2px solid #3498db;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            position: relative;
        }

        .controls-preview {
            height: 40px;
            display: flex;
            gap: 8px;
            justify-content: center;
            align-items: center;
        }

        .info-preview {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 8px;
            border-radius: 5px;
            flex: 1;
            font-size: 0.9em;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .next-piece-preview {
            width: 40px;
            height: 40px;
            border: 1px solid #3498db;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 3px;
            flex: 0 0 40px;
        }
    </style>
</head>
<body>
    <h1>选择游戏</h1>
    <button class="game-button" data-preview="snake" onclick="window.location.href='game1.html'">
        贪吃蛇
    </button>
    <button class="game-button" data-preview="tetris" onclick="window.location.href='game2.html'">
        俄罗斯方块
    </button>

    <div class="preview-container">
        <div id="snake-preview" class="preview-content">
            <div class="game-preview">
                <div class="game-board-preview">
                    <!-- 贪吃蛇游戏预览内容 -->
                    <div style="position: absolute; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: rgba(255,255,255,0.5);">
                        贪吃蛇游戏预览
                    </div>
                </div>
                <div class="controls-preview">
                    <div class="info-preview">得分: 0</div>
                    <div class="info-preview">等级: 1</div>
                </div>
            </div>
        </div>

        <div id="tetris-preview" class="preview-content">
            <div class="game-preview">
                <div class="game-board-preview">
                    <!-- 俄罗斯方块游戏预览内容 -->
                    <div style="position: absolute; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: rgba(255,255,255,0.5);">
                        俄罗斯方块预览
                    </div>
                </div>
                <div class="controls-preview">
                    <div class="info-preview">得分: 0</div>
                    <div class="info-preview">等级: 1</div>
                    <div class="next-piece-preview"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const buttons = document.querySelectorAll('.game-button');
        const previewContainer = document.querySelector('.preview-container');
        const previews = {
            snake: document.getElementById('snake-preview'),
            tetris: document.getElementById('tetris-preview')
        };
        
        buttons.forEach(button => {
            button.addEventListener('mouseenter', (e) => {
                const previewType = button.getAttribute('data-preview');
                const preview = previews[previewType];
                if (preview) {
                    const rect = button.getBoundingClientRect();
                    
                    preview.style.left = `${rect.left}px`;
                    preview.style.top = `${rect.top - 320}px`;
                    
                    Object.values(previews).forEach(p => p.classList.remove('visible'));
                    preview.classList.add('visible');
                }
            });

            button.addEventListener('mouseleave', () => {
                setTimeout(() => {
                    Object.values(previews).forEach(p => p.classList.remove('visible'));
                }, 100);
            });
        });

        window.addEventListener('resize', () => {
            const visiblePreview = document.querySelector('.preview-content.visible');
            if (visiblePreview) {
                const button = document.querySelector(`[data-preview="${visiblePreview.id.split('-')[0]}"]`);
                const rect = button.getBoundingClientRect();
                visiblePreview.style.left = `${rect.left}px`;
                visiblePreview.style.top = `${rect.top - 320}px`;
            }
        });

        // 添加预览动画
        class GamePreview {
            constructor() {
                this.snakePreview = {
                    canvas: document.createElement('canvas'),
                    snake: [
                        {x: 2, y: 5}, {x: 1, y: 5}, {x: 0, y: 5}, {x: -1, y: 5}
                    ],
                    obstacles: [
                        {x: 12, y: 5},  // 路径上的障碍物保持在最右侧
                        {x: 4, y: 2},   // 其他障碍物分散放置
                        {x: 8, y: 8}
                    ],
                    direction: 'right',
                    gridSize: 20,
                    deathState: {
                        isAnimating: false,
                        frameCount: 0,
                        maxFrames: 15,
                        particles: []
                    },
                    moveQueue: [
                        ...Array(20).fill('right'),
                        ...Array(5).fill('down'),
                        ...Array(10).fill('left'),
                        ...Array(5).fill('up')
                    ],
                    moveIndex: 0
                };

                this.tetrisPreview = {
                    canvas: document.createElement('canvas'),
                    pieces: [
                        [[1, 1, 1, 1]],  // I
                        [[1, 1], [1, 1]],  // O
                        [[1, 1, 1], [0, 1, 0]],  // T
                        [[1, 1, 0], [0, 1, 1]],  // Z
                        [[0, 1, 1], [1, 1, 0]]   // S
                    ],
                    currentPiece: {
                        shape: [[1, 1, 1], [0, 1, 0]],
                        x: 3,
                        y: 0
                    },
                    grid: Array(10).fill().map(() => Array(10).fill(0)),
                    colors: ['#00f0f0', '#f0f000', '#a000f0', '#00f000', '#f00000'],
                    pieceIndex: 0,
                    isResetting: false,
                    resetDelay: 500,
                    clearAnimation: {
                        isPlaying: false,
                        frameCount: 0,
                        maxFrames: 6,  // 闪烁3次，每次2帧
                        lines: []      // 要消除的行
                    }
                };

                this.initializeCanvases();
                this.startAnimations();
            }

            initializeCanvases() {
                // 设置贪吃蛇预览画布
                const snakeBoard = document.querySelector('#snake-preview .game-board-preview');
                this.snakePreview.canvas.width = snakeBoard.clientWidth;
                this.snakePreview.canvas.height = snakeBoard.clientHeight;
                snakeBoard.innerHTML = '';
                snakeBoard.appendChild(this.snakePreview.canvas);
                this.snakePreview.ctx = this.snakePreview.canvas.getContext('2d');

                // 设置俄罗斯方块预览画布
                const tetrisBoard = document.querySelector('#tetris-preview .game-board-preview');
                this.tetrisPreview.canvas.width = tetrisBoard.clientWidth;
                this.tetrisPreview.canvas.height = tetrisBoard.clientHeight;
                tetrisBoard.innerHTML = '';
                tetrisBoard.appendChild(this.tetrisPreview.canvas);
                this.tetrisPreview.ctx = this.tetrisPreview.canvas.getContext('2d');
            }

            startAnimations() {
                // 贪吃蛇动画
                setInterval(() => this.updateSnakePreview(), 200);
                // 俄罗斯方块动画
                setInterval(() => this.updateTetrisPreview(), 500);
            }

            updateSnakePreview() {
                const ctx = this.snakePreview.ctx;
                const gridSize = this.snakePreview.gridSize;
                
                // 如果正在播放死亡动画
                if (this.snakePreview.deathState.isAnimating) {
                    this.updateDeathAnimation();
                    return;
                }

                // 清空画布
                ctx.clearRect(0, 0, this.snakePreview.canvas.width, this.snakePreview.canvas.height);
                
                // 绘制网格
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                for(let i = 0; i <= this.snakePreview.canvas.width; i += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, this.snakePreview.canvas.height);
                    ctx.stroke();
                }
                for(let i = 0; i <= this.snakePreview.canvas.height; i += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(this.snakePreview.canvas.width, i);
                    ctx.stroke();
                }

                // 计算下一个位置
                const head = {...this.snakePreview.snake[0]};
                const direction = this.snakePreview.moveQueue[this.snakePreview.moveIndex];
                
                switch(direction) {
                    case 'right': head.x++; break;
                    case 'left': head.x--; break;
                    case 'up': head.y--; break;
                    case 'down': head.y++; break;
                }

                // 检查是否会撞到障碍物
                const willCollide = this.snakePreview.obstacles.some(obs => 
                    obs.x === head.x && obs.y === head.y
                );

                if (willCollide) {
                    this.startDeathAnimation(head);
                    return;
                }

                // 更新蛇的位置
                this.snakePreview.snake.unshift(head);
                this.snakePreview.snake.pop();

                // 更新移动索引
                this.snakePreview.moveIndex = (this.snakePreview.moveIndex + 1) % this.snakePreview.moveQueue.length;

                // 绘制所有元素
                this.drawGrid();
                this.drawObstacles();
                this.drawSnake();
            }

            startDeathAnimation(collisionPos) {
                this.snakePreview.deathState.isAnimating = true;
                this.snakePreview.deathState.frameCount = 0;
                this.snakePreview.deathState.collisionPos = collisionPos;

                // 增加粒子速度
                this.snakePreview.deathState.particles = Array.from({length: 20}, () => ({
                    x: (collisionPos.x + 0.5) * this.snakePreview.gridSize,
                    y: (collisionPos.y + 0.5) * this.snakePreview.gridSize,
                    angle: Math.random() * Math.PI * 2,
                    speed: Math.random() * 8 + 4,
                    size: Math.random() * this.snakePreview.gridSize * 0.8,
                    alpha: 1,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.4
                }));
            }

            updateDeathAnimation() {
                const ctx = this.snakePreview.ctx;
                const state = this.snakePreview.deathState;
                const progress = state.frameCount / state.maxFrames;

                // 清空画布
                ctx.clearRect(0, 0, this.snakePreview.canvas.width, this.snakePreview.canvas.height);

                // 绘制网格和障碍物（淡出效果）
                ctx.globalAlpha = 1 - progress;
                this.drawGrid();
                this.drawObstacles();
                this.drawSnake();
                ctx.globalAlpha = 1;

                // 更新和绘制粒子
                state.particles.forEach(particle => {
                    particle.x += Math.cos(particle.angle) * particle.speed;
                    particle.y += Math.sin(particle.angle) * particle.speed;
                    particle.alpha = 1 - progress;
                    particle.rotation += particle.rotationSpeed;

                    ctx.save();
                    ctx.translate(particle.x, particle.y);
                    ctx.rotate(particle.rotation);
                    ctx.fillStyle = `rgba(255, 0, 0, ${particle.alpha})`;
                    ctx.fillRect(-particle.size/2, -particle.size/2, particle.size, particle.size);
                    ctx.restore();
                });

                // 绘制碰撞波纹
                const radius = this.snakePreview.gridSize * (1 + progress * 2);
                ctx.beginPath();
                ctx.arc(
                    (state.collisionPos.x + 0.5) * this.snakePreview.gridSize,
                    (state.collisionPos.y + 0.5) * this.snakePreview.gridSize,
                    radius,
                    0,
                    Math.PI * 2
                );
                ctx.strokeStyle = `rgba(255, 0, 0, ${1 - progress})`;
                ctx.lineWidth = 3;
                ctx.stroke();

                state.frameCount++;

                // 动画结束后重置
                if (state.frameCount >= state.maxFrames) {
                    state.isAnimating = false;
                    // 重置蛇的位置和方向
                    this.snakePreview.snake = [
                        {x: 2, y: 5}, {x: 1, y: 5}, {x: 0, y: 5}, {x: -1, y: 5}
                    ];
                    this.snakePreview.moveIndex = 0;  // 重置移动序列
                }
            }

            updateTetrisPreview() {
                const ctx = this.tetrisPreview.ctx;
                const blockSize = 25;

                if (this.tetrisPreview.isResetting) {
                    return;
                }

                // 清空画布和绘制网格
                ctx.clearRect(0, 0, this.tetrisPreview.canvas.width, this.tetrisPreview.canvas.height);
                this.drawTetrisGrid(ctx, blockSize);

                // 如果正在播放消除动画
                if (this.tetrisPreview.clearAnimation.isPlaying) {
                    this.updateClearAnimation(ctx, blockSize);
                    return;
                }

                // 绘制已固定的方块
                this.tetrisPreview.grid.forEach((row, y) => {
                    row.forEach((cell, x) => {
                        if (cell) {
                            ctx.fillStyle = this.tetrisPreview.colors[cell - 1];
                            ctx.fillRect(
                                this.tetrisPreview.gridOffset.x + x * blockSize,
                                this.tetrisPreview.gridOffset.y + y * blockSize,
                                blockSize - 1,
                                blockSize - 1
                            );
                        }
                    });
                });

                // 绘制当前方块
                ctx.fillStyle = this.tetrisPreview.colors[this.tetrisPreview.pieceIndex];
                this.tetrisPreview.currentPiece.shape.forEach((row, y) => {
                    row.forEach((cell, x) => {
                        if (cell) {
                            ctx.fillRect(
                                this.tetrisPreview.gridOffset.x + (this.tetrisPreview.currentPiece.x + x) * blockSize,
                                this.tetrisPreview.gridOffset.y + (this.tetrisPreview.currentPiece.y + y) * blockSize,
                                blockSize - 1,
                                blockSize - 1
                            );
                        }
                    });
                });

                // 更新方块位置
                this.tetrisPreview.currentPiece.y++;

                // 检查碰撞
                if (this.checkTetrisCollision()) {
                    // 固定当前方块
                    this.tetrisPreview.currentPiece.shape.forEach((row, y) => {
                        row.forEach((cell, x) => {
                            if (cell) {
                                const gridY = this.tetrisPreview.currentPiece.y - 1 + y;
                                const gridX = this.tetrisPreview.currentPiece.x + x;
                                if (gridY >= 0 && gridY < 10 && gridX >= 0 && gridX < 10) {
                                    this.tetrisPreview.grid[gridY][gridX] = this.tetrisPreview.pieceIndex + 1;
                                }
                            }
                        });
                    });

                    // 检查是否有完整行
                    const fullLines = [];
                    for (let y = 0; y < this.tetrisPreview.grid.length; y++) {
                        if (this.tetrisPreview.grid[y].every(cell => cell)) {
                            fullLines.push(y);
                        }
                    }

                    if (fullLines.length > 0) {
                        // 开始消除动画
                        this.tetrisPreview.clearAnimation.isPlaying = true;
                        this.tetrisPreview.clearAnimation.frameCount = 0;
                        this.tetrisPreview.clearAnimation.lines = fullLines;
                        return;
                    }

                    // 检查顶部距离
                    let topDistance = 0;
                    for (let y = 0; y < this.tetrisPreview.grid.length; y++) {
                        if (this.tetrisPreview.grid[y].some(cell => cell)) {
                            topDistance = y;
                            break;
                        }
                    }

                    // 如果顶部距离为1，开始重置
                    if (topDistance <= 1) {
                        this.tetrisPreview.isResetting = true;
                        setTimeout(() => {
                            this.resetTetrisPreview();
                        }, this.tetrisPreview.resetDelay);
                    } else {
                        // 生成新方块
                        this.spawnNewTetrisPiece();
                    }
                }
            }

            checkTetrisCollision() {
                return this.tetrisPreview.currentPiece.shape.some((row, y) => {
                    return row.some((cell, x) => {
                        if (!cell) return false;
                        const newY = this.tetrisPreview.currentPiece.y + y;
                        const newX = this.tetrisPreview.currentPiece.x + x;
                        return (
                            newY >= 10 ||
                            newX < 0 ||
                            newX >= 10 ||
                            (this.tetrisPreview.grid[newY]?.[newX])
                        );
                    });
                });
            }

            spawnNewTetrisPiece() {
                this.tetrisPreview.pieceIndex = (this.tetrisPreview.pieceIndex + 1) % this.tetrisPreview.pieces.length;
                this.tetrisPreview.currentPiece = {
                    shape: this.tetrisPreview.pieces[this.tetrisPreview.pieceIndex],
                    x: 3,
                    y: 0
                };
            }

            resetTetrisPreview() {
                // 重置所有状态
                this.tetrisPreview.grid = Array(10).fill().map(() => Array(10).fill(0));
                this.tetrisPreview.pieceIndex = 0;
                this.tetrisPreview.currentPiece = {
                    shape: this.tetrisPreview.pieces[0],
                    x: 3,
                    y: 0
                };
                this.tetrisPreview.isResetting = false;
            }

            drawTetrisGrid(ctx, blockSize) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                const width = this.tetrisPreview.canvas.width;
                const height = this.tetrisPreview.canvas.height;
                const cols = Math.floor(width / blockSize);
                const rows = Math.floor(height / blockSize);
                
                // 计算偏移量使网格居中
                const offsetX = (width - cols * blockSize) / 2;
                const offsetY = (height - rows * blockSize) / 2;
                
                // 绘制垂直线
                for(let i = 0; i <= cols; i++) {
                    const x = offsetX + i * blockSize;
                    ctx.beginPath();
                    ctx.moveTo(x, offsetY);
                    ctx.lineTo(x, offsetY + rows * blockSize);
                    ctx.stroke();
                }
                
                // 绘制水平线
                for(let i = 0; i <= rows; i++) {
                    const y = offsetY + i * blockSize;
                    ctx.beginPath();
                    ctx.moveTo(offsetX, y);
                    ctx.lineTo(offsetX + cols * blockSize, y);
                    ctx.stroke();
                }

                // 存储网格信息供其他方法使用
                this.tetrisPreview.gridOffset = { x: offsetX, y: offsetY };
            }

            drawGrid() {
                const ctx = this.snakePreview.ctx;
                const gridSize = this.snakePreview.gridSize;
                const width = this.snakePreview.canvas.width;
                const height = this.snakePreview.canvas.height;
                const cols = Math.floor(width / gridSize);
                const rows = Math.floor(height / gridSize);
                
                // 计算偏移量使网格居中
                const offsetX = (width - cols * gridSize) / 2;
                const offsetY = (height - rows * gridSize) / 2;
                
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                
                // 绘制垂直线
                for(let i = 0; i <= cols; i++) {
                    const x = offsetX + i * gridSize;
                    ctx.beginPath();
                    ctx.moveTo(x, offsetY);
                    ctx.lineTo(x, offsetY + rows * gridSize);
                    ctx.stroke();
                }
                
                // 绘制水平线
                for(let i = 0; i <= rows; i++) {
                    const y = offsetY + i * gridSize;
                    ctx.beginPath();
                    ctx.moveTo(offsetX, y);
                    ctx.lineTo(offsetX + cols * gridSize, y);
                    ctx.stroke();
                }

                // 存储网格信息供其他方法使用
                this.snakePreview.gridOffset = { x: offsetX, y: offsetY };
            }

            drawObstacles() {
                const ctx = this.snakePreview.ctx;
                const gridSize = this.snakePreview.gridSize;
                
                this.snakePreview.obstacles.forEach(obs => {
                    const x = this.snakePreview.gridOffset.x + obs.x * gridSize;
                    const y = this.snakePreview.gridOffset.y + obs.y * gridSize;
                    
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(x, y, gridSize - 1, gridSize - 1);
                    
                    ctx.beginPath();
                    ctx.strokeStyle = '#B8860B';
                    ctx.lineWidth = 2;
                    
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + gridSize - 1, y + gridSize - 1);
                    
                    ctx.moveTo(x + gridSize - 1, y);
                    ctx.lineTo(x, y + gridSize - 1);
                    
                    ctx.stroke();
                });
            }

            drawSnake() {
                const ctx = this.snakePreview.ctx;
                const gridSize = this.snakePreview.gridSize;
                
                ctx.fillStyle = '#4CAF50';
                this.snakePreview.snake.forEach(segment => {
                    ctx.fillRect(
                        this.snakePreview.gridOffset.x + segment.x * gridSize,
                        this.snakePreview.gridOffset.y + segment.y * gridSize,
                        gridSize - 1,
                        gridSize - 1
                    );
                });
            }

            updateClearAnimation(ctx, blockSize) {
                // 绘制固定的方块
                this.tetrisPreview.grid.forEach((row, y) => {
                    row.forEach((cell, x) => {
                        if (cell) {
                            // 如果是要消除的行，根据帧数决定是否显示
                            if (this.tetrisPreview.clearAnimation.lines.includes(y)) {
                                if (Math.floor(this.tetrisPreview.clearAnimation.frameCount / 2) % 2 === 0) {
                                    ctx.fillStyle = '#FFFFFF';  // 闪烁时显示白色
                                } else {
                                    ctx.fillStyle = this.tetrisPreview.colors[cell - 1];
                                }
                            } else {
                                ctx.fillStyle = this.tetrisPreview.colors[cell - 1];
                            }
                            ctx.fillRect(
                                this.tetrisPreview.gridOffset.x + x * blockSize,
                                this.tetrisPreview.gridOffset.y + y * blockSize,
                                blockSize - 1,
                                blockSize - 1
                            );
                        }
                    });
                });

                this.tetrisPreview.clearAnimation.frameCount++;

                // 动画结束后清除行并继续游戏
                if (this.tetrisPreview.clearAnimation.frameCount >= this.tetrisPreview.clearAnimation.maxFrames) {
                    // 清除完整行
                    this.tetrisPreview.clearAnimation.lines.sort((a, b) => b - a).forEach(line => {
                        this.tetrisPreview.grid.splice(line, 1);
                        this.tetrisPreview.grid.unshift(Array(10).fill(0));
                    });

                    this.tetrisPreview.clearAnimation.isPlaying = false;
                    
                    // 检查顶部距离
                    let topDistance = 0;
                    for (let y = 0; y < this.tetrisPreview.grid.length; y++) {
                        if (this.tetrisPreview.grid[y].some(cell => cell)) {
                            topDistance = y;
                            break;
                        }
                    }

                    // 如果顶部距离为1，开始重置
                    if (topDistance <= 1) {
                        this.tetrisPreview.isResetting = true;
                        setTimeout(() => {
                            this.resetTetrisPreview();
                        }, this.tetrisPreview.resetDelay);
                    } else {
                        // 生成新方块
                        this.spawnNewTetrisPiece();
                    }
                }
            }
        }

        // 创建预览动画实例
        const gamePreview = new GamePreview();
    </script>
</body>
</html> 